ob_start()		打开一个输出缓冲区，所有输出信息不再直接发送到浏览器，而是保存到输出缓冲区里面

ob_clean()		删除内部缓冲区的内容，不关闭缓冲区（不输出）

ob_end_clean()	删除内部缓冲区的内容，关闭缓冲区（不输出）

ob_get_clean()	返回缓冲区的内容，关闭缓冲区，相当于执行ob_get_contents()和ob_end_clean()

ob_flush()		发送内部缓冲区的内容到浏览器，删除缓冲区的内容，不关闭缓冲区

ob_end_flush()	发送内部缓冲区的内容到浏览器，删除缓冲区的内容，关闭缓冲区。

ob_get_flush()       返回内部缓冲区的内容，并关闭缓冲区，再释放缓冲区的内容。相当于ob_end_flush()并返回缓冲区内容。

flush()			将ob_flush释放出来的内容，以及不在PHP缓冲区中的内容，全部输出至浏览器；刷新内部缓冲区的内容，并输出。

ob_get_contents()	返回缓冲区的内容，不输出。
ob_get_length()		返回内部缓冲区的长度，如果缓冲区未被激活，该函数返回FALSE。
ob_get_level()		返回输出缓冲机制的嵌套级别
ob_get_status()		得到所有输出缓冲区的状态

ob_end_clean()与ob_clean()
　　这两个函数从字面意思上就可以看出其区别。前者清除缓冲区内容并且关闭，后者仅仅是做清除工作。需要注意的是，使用了这两个函数，在前面使用了echo、print_r等函数不会输出内容。
　　笔者曾经试图通过print_r打印出ob_get_contents()的内容，然后调用ob_clean()清除缓冲区，以免影响后面对缓冲区的操作，屡屡失败。仔细想想，print_r的内容再次写入缓冲区，而后面做了ob_clean()的操作，自然不会有任何输出。在ob_clean操作之前调用ob_flush()函数便可达到预想的效果。

ob_flush()送出缓冲区的内容并且丢弃内容。因而在此函数之前最好采用ob_get_contents()获得缓冲区内容。flush()刷出服务器端缓冲，并且发往客户端。因而从流程上来说，应该是先调用ob_flush()而后再调用flush函数。